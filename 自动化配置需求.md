# 自动化配载需求总结

## 关于批量发起请求

项目中，有时会有这种场景，需要批量的发起多个请求。例如页面有多个下拉枚举值需要从接口中获取，这是我们可以利用promise 进行批量的请求。

基本过程：

- 1、 在本地定义常量字段和请求url的映射（map）
- 2、遍历map，生成一个promise数组
- 3、使用promise.allSettled()方法统计对请求结果进行处理（成功or失败）

```js
 /** 定义枚举请求映射 */
    const fetchEnumMap = {
      [constants1: service1,
      [constants2]: ervice.2,
      ....
    };

    /** 构造promise请求数组 */
    const allPromise = Object.entries(fetchEnumMap).map(([enumName, enumService]) => {
      return new Promise((resolve, reject) => {
        enumService().then(
          (result) => {
            resolve({
              enumName,
              enumServiceResult: result.map(item => ({ value: item.value || item.code, label: item.desc || item.name }))
            });
          },
          (e) => {
            console.error(`${enumName} error:`, e);
            reject(e);
          }
        );
      });
    });

    /** 对结果统一处理*/
    const enumMap = {};
    const resultPromises = await Promise.allSettled(allPromise);
    resultPromises.forEach(v => {
      if (v.status !== 'fulfilled') {
        console.error('promise fail', v);
        return;
      }
      const { enumName, enumServiceResult } = v.value;
      enumMap[enumName] = enumServiceResult;
    });
```

>**注意1：**
>
>需求注意的一点是批量请求的调用时机，批量请求在第二步时就会调用，**因为promise一旦建立就会立即执行**，第三步的allSettled方法只是对请求结果的统一处理，并不是调用allSettled方法是才发起请求。

>**注意2：**
>
>promise.all()或promise.allSettled()方法里的多个请求是并发的吗？
>
>请注意：这是个伪命题，这两个方法里的每个promise并没有什么并行和串行的概念，promise.all()这个api是指代码的一种组织方式，（**Promise 是一个模式，一种组织异步代码的方法，跟线程毫无关系。**）用来标识多个操作全部完成后动作。
>
>一条基本关系：`并行和串行是概念，线程/进程/事件循环等是实现。`
>
>js并没有线程的概念，js有的是一套事件轮训机制。js中看上去的并行操作，其实都是由于事件轮询机制。
>
>**举两个例子：**
>
>- 1、promise.all中的promise封装的是同步操作（例如计算）
>- 2、promise.all中的promise封装的是异步操作（例如定时器）
>
>验证：
>
>当为异步任务时：
>
>```js
>   // 获取随机数，toFixed为四舍五入保留小数，0为保留整数，范围～1000
>   const getRandom = () => +(Math.random() * 1000).toFixed(0);
>
>   const asyncTask = (taskID) => new Promise((resolve) => {
>       // 随机获取一次0~1000的随机数
>       let timeout = getRandom();
>       // 打印出传递进来的ID号 taskID=1 start.
>       console.log(`taskID=${taskID} start.`);
>       // 设置计时时间，function()等价于 () => {...}
>       setTimeout(function () {
>           // 打印出执行的taskID,和timeout
>           console.log(`taskID=${taskID} finished in time=${timeout}.`);
>           // 异步成功执行
>           resolve(taskID)
>       }, timeout);
>   });
>
>   Promise.all([asyncTask(1), asyncTask(2), asyncTask(3)])
>       .then(resultList => {
>           console.log('results:', resultList);
>       });
>```
>
>打印结果：
>
>![](http://qiniu.wind-zhou.com/wind-zhou/2022-05-12-093040.png)
>
>这个结果说明如果promise里面是异步任务，那么看上去是并发执行的，并发的原因就是js的事件轮询机制。
>
>> 这里面还有宏任务和微任务的概念，setTimeout是宏任务，promise是微任务，执行时先微任务再执行宏任务，因此每个promise都会首先执行，然后将setTimeout扔进异步任务队列，当setTimeout时间到达时，开始执行setTimeout的回调函数（console.log()）
>
>但是如果promise中是同步的操作，例如数值计算，则会表现为串行输出。
>
>```js
>
>    const getRandom = () => +(Math.random() * 1000).toFixed(0);
>    const asyncTask = (taskID) => new Promise((resolve) => {
>        let i = 0;
>        let res = 0;
>        while (i++ < Math.floor(Math.random() * 40)) {
>            res += i
>        }
>        console.log(`taskID=${taskID} finished res=${res}.`)
>    });
>
>    Promise.all([asyncTask(1), asyncTask(2), asyncTask(3)])
>        .then(resultList => {
>            console.log('results:', resultList);
>        });
>```
>
>无论刷新几次，都是taskId都是按照1,2,3串行输出。
>
>![](http://qiniu.wind-zhou.com/wind-zhou/2022-05-14-073947.png)

## 事件轮询

### 宏任务与微任务

- 宏任务：setTimeout，setInterval，Ajax，DOM事件
- 微任务：Promise，async/await

`微任务会比宏任务先执行`

### 事件轮询机制

![](http://qiniu.wind-zhou.com/wind-zhou/2022-05-14-090127.png)

![](http://qiniu.wind-zhou.com/wind-zhou/2022-05-14-090245.png)

### event loop 与DOM事件的关系

![](http://qiniu.wind-zhou.com/wind-zhou/2022-05-14-090401.png)

定时器和DOM事件的调用时机不太一样（定时器时间到了后执行，dom事件在触发后执行），但他们的异步都是基于回调函数，**只要是回调函数都可以用事件轮询的机制去解释。**

>**解释**：dom事件在代码执行到绑定事件时，也会将其先放入web apis中，但和定时器不同的是，何时将时间回调放入回调队列中，则取决于何时出发事件操作。（定时器是时间到了后自动放入callBack Queue中）

### event loop 和DOM 渲染之间的关系

>**基本关系：js是单线程的，event Loop和DOM渲染共用一个线程。**

这也是为什么解析html文件时，遇到script标签会暂停dom的解析。

![](http://qiniu.wind-zhou.com/wind-zhou/2022-05-14-092514.png)

1. callBack Stack 空闲
2. 尝试DOM渲染
3. 出发Event Loop

![](http://qiniu.wind-zhou.com/wind-zhou/2022-05-14-093145.png)



### 为什么微任务比宏任务更早

> 因为微任务再DOM渲染之前执行

![](http://qiniu.wind-zhou.com/wind-zhou/2022-05-14-093442.png)

![](http://qiniu.wind-zhou.com/wind-zhou/2022-05-14-094020.png)

这里关于微任务的回调其实并不是放到了CallBack Queue中，而是单独有一个微任务队列 micro task queue。

> **微任务**：由ES6 语法规定（不是W3C规范）。
>
> **宏任务**：由浏览器决定的。

## 关于promise控制请求的并发数量

需求中某些时候需要控制每个时刻前端请求的并发数量。

解决思路：可以利用队列的思想实现，可以先将所有的请求都推进队列，然后按照根据最大数量，对其进行遍历的取出并调用，每次取出的请求返回结果后，则再次增加一个新的调用，已保证每个时刻请求的数量都不超过最大值的限制。

![](http://qiniu.wind-zhou.com/wind-zhou/2022-05-14-074736.png)



```js

<script>
    // 创建任务
    function createTask(i) {
        return () => {
            return new Promise((recolve, reject) => {
                setTimeout(() => {
                    recolve(i)
                }, 2000)
            })
        }
    }

    // 自定义task 队列
    class TaskQueue {
        constructor(props) {
            this.max = props.max; // 最大并发限制
            this.taskList = []; // 任务队列
            setTimeout(() => { // 异步任务，在执行完addTask后会执行此回调
                this.run();
            })
        }

        // 任务列表进入队列
        addTask(taskList) {
            this.taskList.push(taskList)
        }

        // 运行函数
        run() {
            const length = this.taskList.length;
            if (!length) {
                return
            }
            // 每次遍历取出指定数量的task并执行
            let min = Math.min(this.max, this.taskList.length);
            // 每次取出后，任务数量减1
            for (let i = 0; i < min; i++) {
                const task = this.taskList.shift(); // 每次取出队首的task
                this.max--;
                task().then((res) => {
                    console.log(res); // 这里一般执行本地数据的存储操作
                }).catch(err => {
                    console.log(err);
                }).finally(() => {
                    // 执行结束后，可执行数量加1
                    this.max++;
                    this.run(); // 再次递归的调用运行函数，还会重新走一次for循环，只不过后面每次的循环次数都为1
                })
            }
        }

    }

    const taskQueue = new TaskQueue({
        max: 2 // 控制并发请求
    });
    for (let i = 0; i < 20; i++) {
        const task = createTask(i);
        taskQueue.addTask(task);
    }
</script>

```



![](http://qiniu.wind-zhou.com/wind-zhou/2022-05-14-promise.gif)



## 浏览器是如何工作的

直接上b站链接

https://www.bilibili.com/read/cv7963170?spm_id_from=333.999.0.0

<iframe src="//player.bilibili.com/player.html?aid=840997499&bvid=BV1x54y1B7RE&cid=200801840&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

