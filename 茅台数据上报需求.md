# 茅台数据上报需求总结

## 关于iframe的页面嵌套

本次需求是一个页面，四个tab，其中两个tab需要把既有的页通过iframe嵌套过来，这其中遇到一个问题，页面加载有些慢，为了提升用户体验，需要给其添加loading。

具体代码：

```js
const DutyConfig = React.memo(() => {
    const [isLoading, setLoading] = useState(false);
    const iframeRef = useRef(null); // 初始值

    useEffect(() => {
        setLoading(true);
        let iframe = iframeRef.current;
        if (iframe.attachEvent) { // IE
            iframe.attachEvent('onload', () => { setLoading(false); });
        } else { // 非IE
            iframe.onload = () => { setLoading(false); };
        }
      /*  组件销毁时，解除绑定事件*/ 
        return () => {  
            if (iframe.attachEvent) { // IE
              // ...Ï
            } else { // 非IE
                iframe.onload = false;
            }
        };
    }, []);
    return <Loading inline={false} visible={isLoading} style={{ height: '100%' }} tip="页面正在加载中，请耐心等待！">
        <iframe ref={iframeRef} src="xxx/.html" width="100%" height="100%" frameBorder='0' />
    </Loading>;
});
```

>**基本思路**：
>
>就是在页面加载时，获取到iframe的dom节点，然后给其添加onload事件，再起加载完成后，讲loading取消掉。
>
>**遇到的坑：**
>
>在获取iframe的dom节点是，最开始并不是使用的ref获取，而是直接使用原生的 document.getElementsByTagName[0],这时出现了一个bug，在第三个tab的iframe的嵌套页面加载完成后，点击加载第四个tab的iframe，结果第四个tab的iframe页面加载完成了，但是loading却没有取消。
>
>原因：排查后发现，第四个页面通过document.getElementsByTagName[0] 获取到的iframe节点是第三个页面的iframe节点，这是由于第三个tab的iframe节点节点已经加载完成，因此不会再次触发，所以loading状态未变化。
>
>**总结：**这个问题归根到底由于使用document.getElementsByTagName获取节点集合，获取的是当前页面所有的节点集合，而不是只有组件的结合（**document.getElementsByTagName 获取的节点集合的粒度是页面而不是组件**）  。使用hooks useRef就可以避免这个问题。

## flex 实现问题与div的上对齐

![](http://qiniu.wind-zhou.com/wind-zhou/2022-05-12-081930.png)

## axois 请求适合超时时间timeout

请求的超时时间可以在前端设置也可以在后端设置

区别：

前端设置：超过指定时间后，如果没有服务端响应则报请求失败

后端设置：有相应报文，但里面无数据，报错信息也由后端定义。



